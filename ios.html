<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>iOS AR (Controlled)</title>
    <style>
      html, body { margin:0; height:100%; overflow:hidden; background:#000; }
      #hud{
        position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
        z-index:10; background:rgba(0,0,0,.72); color:#fff;
        padding:10px 14px; border-radius:12px;
        font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
        font-size:14px; line-height:1.25; max-width:92vw; text-align:center;
        pointer-events:none;
      }
      canvas{ display:block; }
    </style>
  </head>
  <body>
    <div id="hud">Tap to place the model.</div>

    <script type="module">
      import * as THREE from "https://esm.sh/three@0.160.0";
      import * as ZapparThree from "https://esm.sh/@zappar/zappar-threejs@2.2.2";
      import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

      const MODEL_URL = "./Siemens%20CH.glb";  // recomendo renomear para Siemens_CH.glb
      const PLACE_DISTANCE_METERS = 2.0;
      const INITIAL_MODEL_SCALE = 0.01;

      const hud = document.getElementById("hud");

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // IMPORTANT for Zappar camera background
      ZapparThree.glContextSet(renderer.getContext());

      // Scene + Camera
      const scene = new THREE.Scene();
      const camera = new ZapparThree.Camera();
      scene.add(camera);
      scene.background = camera.backgroundTexture;

      // Light
      scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 1));

      // Permission + start camera
      const granted = await ZapparThree.permissionRequestUI();
      if (!granted) {
        hud.textContent = "Camera permission required.";
        throw new Error("Camera permission denied");
      }
      camera.start();

      // World tracking
      const tracker = new ZapparThree.InstantWorldTracker();
      const anchorGroup = new ZapparThree.InstantWorldAnchorGroup(camera, tracker);
      scene.add(anchorGroup);

      // Load model
      const loader = new GLTFLoader();
      const modelRoot = new THREE.Group();
      anchorGroup.add(modelRoot);

      let model = null;
      loader.load(MODEL_URL, (gltf) => {
        model = gltf.scene;
        model.visible = false;
        model.scale.setScalar(INITIAL_MODEL_SCALE);
        modelRoot.add(model);
        hud.textContent = "Tap to place. Drag to rotate. Pinch to scale.";
      }, undefined, () => {
        hud.textContent = "Failed to load model (.glb). Check file name/path.";
      });

      // Place in front
      let placed = false;
      function placeInFront() {
        tracker.setAnchorPoseFromCameraOffset(0, 0, -PLACE_DISTANCE_METERS);
        if (model) model.visible = true;
        placed = true;
      }

      // Touch rotate + pinch scale
      let dragging = false, lastX = 0;
      let pinchStart = 0, startScale = INITIAL_MODEL_SCALE;

      const dist = (a,b) => Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);

      renderer.domElement.addEventListener("touchstart", (e) => {
        if (!model) return;
        if (!placed) { placeInFront(); return; }

        if (e.touches.length === 1) {
          dragging = true;
          lastX = e.touches[0].clientX;
        } else if (e.touches.length === 2) {
          pinchStart = dist(e.touches[0], e.touches[1]);
          startScale = model.scale.x;
        }
      }, { passive:true });

      renderer.domElement.addEventListener("touchmove", (e) => {
        if (!model) return;

        if (e.touches.length === 1 && dragging) {
          const x = e.touches[0].clientX;
          const dx = x - lastX;
          lastX = x;
          modelRoot.rotation.y += dx * 0.01;
        } else if (e.touches.length === 2 && pinchStart > 0) {
          const d = dist(e.touches[0], e.touches[1]);
          const factor = d / pinchStart;
          const newScale = THREE.MathUtils.clamp(startScale * factor, 0.001, 10);
          model.scale.setScalar(newScale);
        }
      }, { passive:true });

      renderer.domElement.addEventListener("touchend", () => {
        dragging = false;
        pinchStart = 0;
      }, { passive:true });

      // Render loop
      function animate() {
        requestAnimationFrame(animate);
        camera.updateFrame(renderer);
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
